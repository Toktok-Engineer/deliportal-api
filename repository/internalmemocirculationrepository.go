package repository

import (
	"deliportal-api/model"
	"strings"

	"gorm.io/gorm"
)

type InternalMemoCirculationRepository interface {
	CountInternalMemoCirculationAll(internalMemoId int) (count int64, err error)
	FindInternalMemoCirculations(internalMemoId int) (internalMemoCirculationOutput []model.InternalMemoCirculation, err error)
	FindInternalMemoCirculationStat(internalMemoId int, cirStat int) (internalMemoCirculationOutput model.SelectInternalMemoCirculationParameter, err error)
	FindInternalMemoCirculationListStat(internalMemoId int, cirStat int) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationParameter, err error)
	FindInternalMemoCirculationSeq(internalMemoId int, employeeID int) (internalMemoCirculationOutput model.SelectInternalMemoCirculationParameter, err error)
	FindInternalMemoCirculationsOffset(limit int, offset int, order string, dir string, internalMemoId int) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationParameter, err error)
	SearchInternalMemoCirculation(limit int, offset int, order string, dir string, search string, internalMemoId int) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationParameter, err error)
	CountSearchInternalMemoCirculation(search string, internalMemoId int) (count int64, err error)
	FindInternalMemoCirculationById(id uint) (internalMemoCirculationOutput model.SelectInternalMemoCirculationParameter, err error)
	FindExcInternalMemoCirculation(id uint) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationParameter, err error)
	FindInternalMemoCirculationByCompanyId(id uint) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationParameter, err error)
	InsertInternalMemoCirculation(internalMemoCirculation model.InternalMemoCirculation) (internalMemoCirculationOutput model.InternalMemoCirculation, err error)
	UpdateInternalMemoCirculation(internalMemoCirculation model.InternalMemoCirculation, id uint) (internalMemoCirculationOutput model.InternalMemoCirculation, err error)
	UpdateInternalMemoCirculationApprove(internalMemoCirculation model.InternalMemoCirculation, id uint) (internalMemoCirculationOutput model.InternalMemoCirculation, err error)
	CountInternalMemoCirculationJoinIM(employeeID int) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationJoinIMParameter, err error)
	FindInternalMemoCirculationsJoinIMOffset(limit int, offset int, order string, dir string, employeeID int) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationJoinIMParameter, err error)
	SearchInternalMemoCirculationJoinIM(limit int, offset int, order string, dir string, search string, employeeID int) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationJoinIMParameter, err error)
	CountSearchInternalMemoCirculationJoinIM(search string, employeeID int) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationJoinIMParameter, err error)
}

type InternalMemoCirculationConnection struct {
	connection *gorm.DB
}

func NewInternalMemoCirculationRepository(db *gorm.DB) InternalMemoCirculationRepository {
	return &InternalMemoCirculationConnection{
		connection: db,
	}
}

func (db *InternalMemoCirculationConnection) CountInternalMemoCirculationAll(internalMemoId int) (count int64, err error) {
	res := db.connection.Table("internal_memo_circulations").Where("internal_memo_id = ? AND deleted_at = 0", internalMemoId).Count(&count)
	return count, res.Error
}

func (db *InternalMemoCirculationConnection) FindInternalMemoCirculations(internalMemoId int) (internalMemoCirculationOutput []model.InternalMemoCirculation, err error) {
	var (
		internalMemoCirculations []model.InternalMemoCirculation
	)
	res := db.connection.Where("internal_memo_id = ? AND deleted_at = 0", internalMemoId).Order("sequence_no").Find(&internalMemoCirculations)
	return internalMemoCirculations, res.Error
}

func (db *InternalMemoCirculationConnection) FindInternalMemoCirculationStat(internalMemoId int, cirStat int) (internalMemoCirculationOutput model.SelectInternalMemoCirculationParameter, err error) {
	var (
		internalMemoCirculation model.SelectInternalMemoCirculationParameter
	)
	res := db.connection.Table("internal_memo_circulations").Select("internal_memo_circulations.id, internal_memo_circulations.internal_memo_id, internal_memo_circulations.employee_id, employees.firstname, employees.lastname, employees.division_id, divisions.division_name, employees.department_id, departments.department_name, internal_memo_circulations.sequence_no, to_char(to_timestamp(internal_memo_circulations.approval_date::numeric), 'DD-Mon-YYYY') as approval_date, internal_memo_circulations.circulation_status, CASE WHEN internal_memo_circulations.circulation_status = 1 THEN 'Pending' WHEN internal_memo_circulations.circulation_status = 2 THEN 'Open' WHEN internal_memo_circulations.circulation_status = 3 THEN 'Back to PIC' WHEN internal_memo_circulations.circulation_status = 4 THEN 'Approved' WHEN internal_memo_circulations.circulation_status = 5 THEN 'Rejected' END AS circulation_status_name, internal_memo_circulations.remark, internal_memo_circulations.created_user_id, createdUID.username AS created_user, internal_memo_circulations.updated_user_id, updatedUID.username AS updated_user, internal_memo_circulations.deleted_user_id, deletedUID.username AS deleted_user, to_char(to_timestamp(internal_memo_circulations.created_at::numeric), 'DD-Mon-YYYY') as created_at, to_char(to_timestamp(internal_memo_circulations.updated_at::numeric), 'DD-Mon-YYYY') as updated_at, to_char(to_timestamp(internal_memo_circulations.deleted_at::numeric), 'DD-Mon-YYYY') as deleted_at").Joins("left join employees on internal_memo_circulations.employee_id = employees.id").Joins("left join divisions on employees.division_id = divisions.id").Joins("left join departments on employees.department_id = departments.id").Joins("left join users createdUID on internal_memo_circulations.created_user_id = createdUID.id").Joins("left join users updatedUID on internal_memo_circulations.updated_user_id = updatedUID.id").Joins("left join users deletedUID on internal_memo_circulations.deleted_user_id = deletedUID.id").Where("internal_memo_circulations.internal_memo_id = ? AND internal_memo_circulations.deleted_at = 0 AND internal_memo_circulations.circulation_status = ?", internalMemoId, cirStat).Order("internal_memo_circulations.sequence_no").Take(&internalMemoCirculation)
	return internalMemoCirculation, res.Error
}

func (db *InternalMemoCirculationConnection) FindInternalMemoCirculationListStat(internalMemoId int, cirStat int) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationParameter, err error) {
	var (
		internalMemoCirculations []model.SelectInternalMemoCirculationParameter
	)
	res := db.connection.Table("internal_memo_circulations").Select("internal_memo_circulations.id, internal_memo_circulations.internal_memo_id, internal_memo_circulations.employee_id, employees.firstname, employees.lastname, employees.division_id, divisions.division_name, employees.department_id, departments.department_name, internal_memo_circulations.sequence_no, to_char(to_timestamp(internal_memo_circulations.approval_date::numeric), 'DD-Mon-YYYY') as approval_date, internal_memo_circulations.circulation_status, CASE WHEN internal_memo_circulations.circulation_status = 1 THEN 'Pending' WHEN internal_memo_circulations.circulation_status = 2 THEN 'Open' WHEN internal_memo_circulations.circulation_status = 3 THEN 'Back to PIC' WHEN internal_memo_circulations.circulation_status = 4 THEN 'Approved' WHEN internal_memo_circulations.circulation_status = 5 THEN 'Rejected' END AS circulation_status_name, internal_memo_circulations.remark, internal_memo_circulations.created_user_id, createdUID.username AS created_user, internal_memo_circulations.updated_user_id, updatedUID.username AS updated_user, internal_memo_circulations.deleted_user_id, deletedUID.username AS deleted_user, to_char(to_timestamp(internal_memo_circulations.created_at::numeric), 'DD-Mon-YYYY') as created_at, to_char(to_timestamp(internal_memo_circulations.updated_at::numeric), 'DD-Mon-YYYY') as updated_at, to_char(to_timestamp(internal_memo_circulations.deleted_at::numeric), 'DD-Mon-YYYY') as deleted_at").Joins("left join employees on internal_memo_circulations.employee_id = employees.id").Joins("left join divisions on employees.division_id = divisions.id").Joins("left join departments on employees.department_id = departments.id").Joins("left join users createdUID on internal_memo_circulations.created_user_id = createdUID.id").Joins("left join users updatedUID on internal_memo_circulations.updated_user_id = updatedUID.id").Joins("left join users deletedUID on internal_memo_circulations.deleted_user_id = deletedUID.id").Where("internal_memo_circulations.internal_memo_id = ? AND internal_memo_circulations.deleted_at = 0 AND internal_memo_circulations.circulation_status = ?", internalMemoId, cirStat).Order("internal_memo_circulations.sequence_no").Find(&internalMemoCirculations)
	return internalMemoCirculations, res.Error
}

func (db *InternalMemoCirculationConnection) FindInternalMemoCirculationSeq(internalMemoId int, employeeID int) (internalMemoCirculationOutput model.SelectInternalMemoCirculationParameter, err error) {
	var (
		internalMemoCirculation model.SelectInternalMemoCirculationParameter
	)
	res := db.connection.Table("internal_memo_circulations").Select("internal_memo_circulations.id, internal_memo_circulations.internal_memo_id, internal_memo_circulations.employee_id, employees.firstname, employees.lastname, employees.division_id, divisions.division_name, employees.department_id, departments.department_name, internal_memo_circulations.sequence_no, to_char(to_timestamp(internal_memo_circulations.approval_date::numeric), 'DD-Mon-YYYY') as approval_date, internal_memo_circulations.circulation_status, CASE WHEN internal_memo_circulations.circulation_status = 1 THEN 'Pending' WHEN internal_memo_circulations.circulation_status = 2 THEN 'Open' WHEN internal_memo_circulations.circulation_status = 3 THEN 'Back to PIC' WHEN internal_memo_circulations.circulation_status = 4 THEN 'Approved' WHEN internal_memo_circulations.circulation_status = 5 THEN 'Rejected' END AS circulation_status_name, internal_memo_circulations.remark, internal_memo_circulations.created_user_id, createdUID.username AS created_user, internal_memo_circulations.updated_user_id, updatedUID.username AS updated_user, internal_memo_circulations.deleted_user_id, deletedUID.username AS deleted_user, to_char(to_timestamp(internal_memo_circulations.created_at::numeric), 'DD-Mon-YYYY') as created_at, to_char(to_timestamp(internal_memo_circulations.updated_at::numeric), 'DD-Mon-YYYY') as updated_at, to_char(to_timestamp(internal_memo_circulations.deleted_at::numeric), 'DD-Mon-YYYY') as deleted_at").Joins("left join employees on internal_memo_circulations.employee_id = employees.id").Joins("left join divisions on employees.division_id = divisions.id").Joins("left join departments on employees.department_id = departments.id").Joins("left join users createdUID on internal_memo_circulations.created_user_id = createdUID.id").Joins("left join users updatedUID on internal_memo_circulations.updated_user_id = updatedUID.id").Joins("left join users deletedUID on internal_memo_circulations.deleted_user_id = deletedUID.id").Where("internal_memo_circulations.internal_memo_id = ? AND internal_memo_circulations.deleted_at = 0 AND internal_memo_circulations.employee_id = ?", internalMemoId, employeeID).Order("internal_memo_circulations.sequence_no").Take(&internalMemoCirculation)
	return internalMemoCirculation, res.Error
}

func (db *InternalMemoCirculationConnection) FindInternalMemoCirculationsOffset(limit int, offset int, order string, dir string, internalMemoId int) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationParameter, err error) {
	var (
		orderDirection           string
		internalMemoCirculations []model.SelectInternalMemoCirculationParameter
	)
	orderDirection = order + " " + dir
	res := db.connection.Table("internal_memo_circulations").Select("internal_memo_circulations.id, internal_memo_circulations.internal_memo_id, internal_memo_circulations.employee_id, employees.firstname, employees.lastname, employees.division_id, divisions.division_name, employees.department_id, departments.department_name, internal_memo_circulations.sequence_no, to_char(to_timestamp(internal_memo_circulations.approval_date::numeric), 'DD-Mon-YYYY') as approval_date, internal_memo_circulations.circulation_status, CASE WHEN internal_memo_circulations.circulation_status = 1 THEN 'Pending' WHEN internal_memo_circulations.circulation_status = 2 THEN 'Open' WHEN internal_memo_circulations.circulation_status = 3 THEN 'Back to PIC' WHEN internal_memo_circulations.circulation_status = 4 THEN 'Approved' WHEN internal_memo_circulations.circulation_status = 5 THEN 'Rejected' END AS circulation_status_name, internal_memo_circulations.remark, internal_memo_circulations.created_user_id, createdUID.username AS created_user, internal_memo_circulations.updated_user_id, updatedUID.username AS updated_user, internal_memo_circulations.deleted_user_id, deletedUID.username AS deleted_user, to_char(to_timestamp(internal_memo_circulations.created_at::numeric), 'DD-Mon-YYYY') as created_at, to_char(to_timestamp(internal_memo_circulations.updated_at::numeric), 'DD-Mon-YYYY') as updated_at, to_char(to_timestamp(internal_memo_circulations.deleted_at::numeric), 'DD-Mon-YYYY') as deleted_at").Joins("left join employees on internal_memo_circulations.employee_id = employees.id").Joins("left join divisions on employees.division_id = divisions.id").Joins("left join departments on employees.department_id = departments.id").Joins("left join users createdUID on internal_memo_circulations.created_user_id = createdUID.id").Joins("left join users updatedUID on internal_memo_circulations.updated_user_id = updatedUID.id").Joins("left join users deletedUID on internal_memo_circulations.deleted_user_id = deletedUID.id").Where("internal_memo_circulations.internal_memo_id = ? AND internal_memo_circulations.deleted_at = 0", internalMemoId).Order(orderDirection).Limit(limit).Offset(offset).Find(&internalMemoCirculations)
	return internalMemoCirculations, res.Error
}

func (db *InternalMemoCirculationConnection) SearchInternalMemoCirculation(limit int, offset int, order string, dir string, search string, internalMemoId int) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationParameter, err error) {
	var (
		orderDirection           string
		final                    string
		internalMemoCirculations []model.SelectInternalMemoCirculationParameter
	)
	orderDirection = order + " " + dir
	final = "%" + strings.ToLower(search) + "%"
	res := db.connection.Table("internal_memo_circulations").Select("internal_memo_circulations.id, internal_memo_circulations.internal_memo_id, internal_memo_circulations.employee_id, employees.firstname, employees.lastname, employees.division_id, divisions.division_name, employees.department_id, departments.department_name, internal_memo_circulations.sequence_no, to_char(to_timestamp(internal_memo_circulations.approval_date::numeric), 'DD-Mon-YYYY') as approval_date, internal_memo_circulations.circulation_status, CASE WHEN internal_memo_circulations.circulation_status = 1 THEN 'Pending' WHEN internal_memo_circulations.circulation_status = 2 THEN 'Open' WHEN internal_memo_circulations.circulation_status = 3 THEN 'Back to PIC' WHEN internal_memo_circulations.circulation_status = 4 THEN 'Approved' WHEN internal_memo_circulations.circulation_status = 5 THEN 'Rejected' END AS circulation_status_name, internal_memo_circulations.remark, internal_memo_circulations.created_user_id, createdUID.username AS created_user, internal_memo_circulations.updated_user_id, updatedUID.username AS updated_user, internal_memo_circulations.deleted_user_id, deletedUID.username AS deleted_user, to_char(to_timestamp(internal_memo_circulations.created_at::numeric), 'DD-Mon-YYYY') as created_at, to_char(to_timestamp(internal_memo_circulations.updated_at::numeric), 'DD-Mon-YYYY') as updated_at, to_char(to_timestamp(internal_memo_circulations.deleted_at::numeric), 'DD-Mon-YYYY') as deleted_at").Joins("left join employees on internal_memo_circulations.employee_id = employees.id").Joins("left join divisions on employees.division_id = divisions.id").Joins("left join departments on employees.department_id = departments.id").Joins("left join users createdUID on internal_memo_circulations.created_user_id = createdUID.id").Joins("left join users updatedUID on internal_memo_circulations.updated_user_id = updatedUID.id").Joins("left join users deletedUID on internal_memo_circulations.deleted_user_id = deletedUID.id").Where("(lower(employees.firstname) LIKE ? OR lower(employees.lastname) LIKE ? OR lower(divisions.division_name) LIKE ? OR lower(departments.department_name) LIKE ? OR lower(to_char(to_timestamp(internal_memo_circulations.approval_date::numeric), 'DD-Mon-YYYY')) LIKE ? OR (CASE WHEN internal_memo_circulations.circulation_status = 1 THEN 'pending' WHEN internal_memo_circulations.circulation_status = 2 THEN 'open' WHEN internal_memo_circulations.circulation_status = 3 THEN 'back to pic' WHEN internal_memo_circulations.circulation_status = 4 THEN 'need file attachment' WHEN internal_memo_circulations.circulation_status = 5 THEN 'approved' END LIKE ?) OR lower(internal_memo_circulations.remark) LIKE ? OR lower(createdUID.username) LIKE ?  OR lower(updatedUID.username) LIKE ? OR lower(to_char(to_timestamp(internal_memo_circulations.created_at::numeric), 'DD-Mon-YYYY')) LIKE ? OR lower(to_char(to_timestamp(internal_memo_circulations.updated_at::numeric), 'DD-Mon-YYYY')) LIKE ?) AND internal_memo_circulations.internal_memo_id = ? AND internal_memo_circulations.deleted_at = 0", final, final, final, final, final, final, final, final, final, final, final, internalMemoId).Order(orderDirection).Limit(limit).Offset(offset).Find(&internalMemoCirculations)

	return internalMemoCirculations, res.Error
}

func (db *InternalMemoCirculationConnection) CountSearchInternalMemoCirculation(search string, internalMemoId int) (count int64, err error) {
	final := "%" + strings.ToLower(search) + "%"
	res := db.connection.Table("internal_memo_circulations").Select("internal_memo_circulations.id, internal_memo_circulations.internal_memo_id, internal_memo_circulations.employee_id, employees.firstname, employees.lastname, employees.division_id, divisions.division_name, employees.department_id, departments.department_name, internal_memo_circulations.sequence_no, to_char(to_timestamp(internal_memo_circulations.approval_date::numeric), 'DD-Mon-YYYY') as approval_date, internal_memo_circulations.circulation_status, CASE WHEN internal_memo_circulations.circulation_status = 1 THEN 'Pending' WHEN internal_memo_circulations.circulation_status = 2 THEN 'Open' WHEN internal_memo_circulations.circulation_status = 3 THEN 'Back to PIC' WHEN internal_memo_circulations.circulation_status = 4 THEN 'Approved' WHEN internal_memo_circulations.circulation_status = 5 THEN 'Rejected' END AS circulation_status_name, internal_memo_circulations.remark, internal_memo_circulations.created_user_id, createdUID.username AS created_user, internal_memo_circulations.updated_user_id, updatedUID.username AS updated_user, internal_memo_circulations.deleted_user_id, deletedUID.username AS deleted_user, to_char(to_timestamp(internal_memo_circulations.created_at::numeric), 'DD-Mon-YYYY') as created_at, to_char(to_timestamp(internal_memo_circulations.updated_at::numeric), 'DD-Mon-YYYY') as updated_at, to_char(to_timestamp(internal_memo_circulations.deleted_at::numeric), 'DD-Mon-YYYY') as deleted_at").Joins("left join employees on internal_memo_circulations.employee_id = employees.id").Joins("left join divisions on employees.division_id = divisions.id").Joins("left join departments on employees.department_id = departments.id").Joins("left join users createdUID on internal_memo_circulations.created_user_id = createdUID.id").Joins("left join users updatedUID on internal_memo_circulations.updated_user_id = updatedUID.id").Joins("left join users deletedUID on internal_memo_circulations.deleted_user_id = deletedUID.id").Where("(lower(employees.firstname) LIKE ? OR lower(employees.lastname) LIKE ? OR lower(divisions.division_name) LIKE ? OR lower(departments.department_name) LIKE ? OR lower(to_char(to_timestamp(internal_memo_circulations.approval_date::numeric), 'DD-Mon-YYYY')) LIKE ? OR (CASE WHEN internal_memo_circulations.circulation_status = 1 THEN 'pending' WHEN internal_memo_circulations.circulation_status = 2 THEN 'open' WHEN internal_memo_circulations.circulation_status = 3 THEN 'back to pic' WHEN internal_memo_circulations.circulation_status = 4 THEN 'need file attachment' WHEN internal_memo_circulations.circulation_status = 5 THEN 'approved' END LIKE ?) OR lower(internal_memo_circulations.remark) LIKE ? OR lower(createdUID.username) LIKE ?  OR lower(updatedUID.username) LIKE ? OR lower(to_char(to_timestamp(internal_memo_circulations.created_at::numeric), 'DD-Mon-YYYY')) LIKE ? OR lower(to_char(to_timestamp(internal_memo_circulations.updated_at::numeric), 'DD-Mon-YYYY')) LIKE ?) AND internal_memo_circulations.internal_memo_id = ? AND internal_memo_circulations.deleted_at = 0", final, final, final, final, final, final, final, final, final, final, final, internalMemoId).Count(&count)
	return count, res.Error
}

func (db *InternalMemoCirculationConnection) FindInternalMemoCirculationById(id uint) (internalMemoCirculationOutput model.SelectInternalMemoCirculationParameter, err error) {
	var (
		internalMemoCirculation model.SelectInternalMemoCirculationParameter
	)

	res := db.connection.Table("internal_memo_circulations").Select("internal_memo_circulations.id, internal_memo_circulations.internal_memo_id, internal_memo_circulations.employee_id, employees.firstname, employees.lastname, employees.division_id, divisions.division_name, employees.department_id, departments.department_name, internal_memo_circulations.sequence_no, to_char(to_timestamp(internal_memo_circulations.approval_date::numeric), 'DD-Mon-YYYY') as approval_date, internal_memo_circulations.circulation_status, CASE WHEN internal_memo_circulations.circulation_status = 1 THEN 'Pending' WHEN internal_memo_circulations.circulation_status = 2 THEN 'Open' WHEN internal_memo_circulations.circulation_status = 3 THEN 'Back to PIC' WHEN internal_memo_circulations.circulation_status = 4 THEN 'Approved' WHEN internal_memo_circulations.circulation_status = 5 THEN 'Rejected' END AS circulation_status_name, internal_memo_circulations.remark, internal_memo_circulations.created_user_id, createdUID.username AS created_user, internal_memo_circulations.updated_user_id, updatedUID.username AS updated_user, internal_memo_circulations.deleted_user_id, deletedUID.username AS deleted_user, to_char(to_timestamp(internal_memo_circulations.created_at::numeric), 'DD-Mon-YYYY') as created_at, to_char(to_timestamp(internal_memo_circulations.updated_at::numeric), 'DD-Mon-YYYY') as updated_at, to_char(to_timestamp(internal_memo_circulations.deleted_at::numeric), 'DD-Mon-YYYY') as deleted_at").Joins("left join employees on internal_memo_circulations.employee_id = employees.id").Joins("left join divisions on employees.division_id = divisions.id").Joins("left join departments on employees.department_id = departments.id").Joins("left join users createdUID on internal_memo_circulations.created_user_id = createdUID.id").Joins("left join users updatedUID on internal_memo_circulations.updated_user_id = updatedUID.id").Joins("left join users deletedUID on internal_memo_circulations.deleted_user_id = deletedUID.id").Where("internal_memo_circulations.id=? AND internal_memo_circulations.deleted_at = 0", id).Take(&internalMemoCirculation)
	return internalMemoCirculation, res.Error
}

func (db *InternalMemoCirculationConnection) FindExcInternalMemoCirculation(id uint) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationParameter, err error) {
	var (
		internalMemoCirculations []model.SelectInternalMemoCirculationParameter
	)

	res := db.connection.Table("internal_memo_circulations").Select("internal_memo_circulations.id, internal_memo_circulations.internal_memo_id, internal_memo_circulations.employee_id, employees.firstname, employees.lastname, employees.division_id, divisions.division_name, employees.department_id, departments.department_name, internal_memo_circulations.sequence_no, to_char(to_timestamp(internal_memo_circulations.approval_date::numeric), 'DD-Mon-YYYY') as approval_date, internal_memo_circulations.circulation_status, CASE WHEN internal_memo_circulations.circulation_status = 1 THEN 'Pending' WHEN internal_memo_circulations.circulation_status = 2 THEN 'Open' WHEN internal_memo_circulations.circulation_status = 3 THEN 'Back to PIC' WHEN internal_memo_circulations.circulation_status = 4 THEN 'Approved' WHEN internal_memo_circulations.circulation_status = 5 THEN 'Rejected' END AS circulation_status_name, internal_memo_circulations.remark, internal_memo_circulations.created_user_id, createdUID.username AS created_user, internal_memo_circulations.updated_user_id, updatedUID.username AS updated_user, internal_memo_circulations.deleted_user_id, deletedUID.username AS deleted_user, to_char(to_timestamp(internal_memo_circulations.created_at::numeric), 'DD-Mon-YYYY') as created_at, to_char(to_timestamp(internal_memo_circulations.updated_at::numeric), 'DD-Mon-YYYY') as updated_at, to_char(to_timestamp(internal_memo_circulations.deleted_at::numeric), 'DD-Mon-YYYY') as deleted_at").Joins("left join employees on internal_memo_circulations.employee_id = employees.id").Joins("left join divisions on employees.division_id = divisions.id").Joins("left join departments on employees.department_id = departments.id").Joins("left join users createdUID on internal_memo_circulations.created_user_id = createdUID.id").Joins("left join users updatedUID on internal_memo_circulations.updated_user_id = updatedUID.id").Joins("left join users deletedUID on internal_memo_circulations.deleted_user_id = deletedUID.id").Where(" internal_memo_circulations.id!=? AND internal_memo_circulations.deleted_at = 0", id).Order("internal_memo_circulations.sequence_no").Find(&internalMemoCirculations)
	return internalMemoCirculations, res.Error
}

func (db *InternalMemoCirculationConnection) FindInternalMemoCirculationByCompanyId(id uint) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationParameter, err error) {
	var (
		internalMemoCirculations []model.SelectInternalMemoCirculationParameter
	)

	res := db.connection.Table("internal_memo_circulations").Select("internal_memo_circulations.id, internal_memo_circulations.internal_memo_id, internal_memo_circulations.employee_id, employees.firstname, employees.lastname, employees.division_id, divisions.division_name, employees.department_id, departments.department_name, internal_memo_circulations.sequence_no, to_char(to_timestamp(internal_memo_circulations.approval_date::numeric), 'DD-Mon-YYYY') as approval_date, internal_memo_circulations.circulation_status, CASE WHEN internal_memo_circulations.circulation_status = 1 THEN 'Pending' WHEN internal_memo_circulations.circulation_status = 2 THEN 'Open' WHEN internal_memo_circulations.circulation_status = 3 THEN 'Back to PIC' WHEN internal_memo_circulations.circulation_status = 4 THEN 'Approved' WHEN internal_memo_circulations.circulation_status = 5 THEN 'Rejected' END AS circulation_status_name, internal_memo_circulations.remark, internal_memo_circulations.created_user_id, createdUID.username AS created_user, internal_memo_circulations.updated_user_id, updatedUID.username AS updated_user, internal_memo_circulations.deleted_user_id, deletedUID.username AS deleted_user, to_char(to_timestamp(internal_memo_circulations.created_at::numeric), 'DD-Mon-YYYY') as created_at, to_char(to_timestamp(internal_memo_circulations.updated_at::numeric), 'DD-Mon-YYYY') as updated_at, to_char(to_timestamp(internal_memo_circulations.deleted_at::numeric), 'DD-Mon-YYYY') as deleted_at").Joins("left join employees on internal_memo_circulations.employee_id = employees.id").Joins("left join divisions on employees.division_id = divisions.id").Joins("left join departments on employees.department_id = departments.id").Joins("left join users createdUID on internal_memo_circulations.created_user_id = createdUID.id").Joins("left join users updatedUID on internal_memo_circulations.updated_user_id = updatedUID.id").Joins("left join users deletedUID on internal_memo_circulations.deleted_user_id = deletedUID.id").Where("internal_memo_circulations.internal_memo_id=? AND internal_memo_circulations.deleted_at = 0", id).Order("internal_memo_circulations.sequence_no").Find(&internalMemoCirculations)
	return internalMemoCirculations, res.Error
}

func (db *InternalMemoCirculationConnection) InsertInternalMemoCirculation(internalMemoCirculation model.InternalMemoCirculation) (internalMemoCirculationOutput model.InternalMemoCirculation, err error) {
	res := db.connection.Save(&internalMemoCirculation)
	return internalMemoCirculation, res.Error
}

func (db *InternalMemoCirculationConnection) UpdateInternalMemoCirculation(internalMemoCirculation model.InternalMemoCirculation, id uint) (internalMemoCirculationOutput model.InternalMemoCirculation, err error) {
	res := db.connection.Where("id=?", id).Updates(&internalMemoCirculation)
	return internalMemoCirculation, res.Error
}

func (db *InternalMemoCirculationConnection) UpdateInternalMemoCirculationApprove(internalMemoCirculation model.InternalMemoCirculation, id uint) (internalMemoCirculationOutput model.InternalMemoCirculation, err error) {
	res := db.connection.Model(&internalMemoCirculation).Where("id=?", id).Updates(map[string]interface{}{"circulation_status": internalMemoCirculation.CirculationStatus, "approval_date": internalMemoCirculation.ApprovalDate, "updated_user_id": internalMemoCirculation.UpdatedUserID, "updated_at": internalMemoCirculation.UpdatedAt})
	return internalMemoCirculation, res.Error
}

func (db *InternalMemoCirculationConnection) CountInternalMemoCirculationJoinIM(employeeID int) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationJoinIMParameter, err error) {
	var (
		internalMemoCirculations []model.SelectInternalMemoCirculationJoinIMParameter
	)
	res := db.connection.Table("internal_memo_circulations").Select("internal_memos.id, internal_memos.internal_memo_no, to_char(to_timestamp(internal_memos.internal_memo_date::numeric), 'DD-Mon-YYYY') as internal_memo_date, internal_memos.internal_memo_type_id, internal_memos.perihal_others, internal_memo_types.internal_memo_type_name, internal_memos.return_to_employee_id, returnToEmployeeID.firstname AS return_to_employee_name, internal_memos.document_no, internal_memos.company_id, companies.company_name, internal_memos.related_party, internal_memos.amount, internal_memos.amount_note, internal_memos.internal_memo_description, internal_memos.internal_memo_result, internal_memos.total_circulation, internal_memos.last_circulation_sequence_no, internal_memos.last_circulation_employee_id, lastCirculationEmployeeName.firstname AS last_circulation_employee_name, internal_memos.status, CASE WHEN internal_memos.status = 1 THEN 'Draft' WHEN internal_memos.status = 2 THEN 'Ask for Approval' WHEN internal_memos.status = 3 THEN 'Back to PIC' WHEN internal_memos.status = 4 THEN 'Approval Completed' WHEN internal_memos.status = 5 THEN 'Rejected' END AS status_name, internal_memos.remark, internal_memos.created_user_id, createdUID.username AS created_user, internal_memos.updated_user_id, updatedUID.username AS updated_user, internal_memos.deleted_user_id, deletedUID.username AS deleted_user, to_char(to_timestamp(internal_memos.created_at::numeric), 'DD-Mon-YYYY') as created_at, to_char(to_timestamp(internal_memos.updated_at::numeric), 'DD-Mon-YYYY') as updated_at, to_char(to_timestamp(internal_memos.deleted_at::numeric), 'DD-Mon-YYYY') as deleted_at, internal_memos.file_name, internal_memos.file_url").Joins("left join internal_memos on internal_memo_circulations.internal_memo_id = internal_memos.id").Joins("left join companies on internal_memos.company_id = companies.id").Joins("left join internal_memo_types on internal_memos.internal_memo_type_id = internal_memo_types.id").Joins("left join employees returnToEmployeeID on internal_memos.return_to_employee_id = returnToEmployeeID.id").Joins("left join employees lastCirculationEmployeeName on internal_memos.last_circulation_employee_id = lastCirculationEmployeeName.id").Joins("left join users createdUID on internal_memos.created_user_id = createdUID.id").Joins("left join users updatedUID on internal_memos.updated_user_id = updatedUID.id").Joins("left join users deletedUID on internal_memos.deleted_user_id = deletedUID.id").Where("internal_memo_circulations.employee_id = ? AND internal_memo_circulations.deleted_at = 0", employeeID).Find(&internalMemoCirculations)
	return internalMemoCirculations, res.Error
}

func (db *InternalMemoCirculationConnection) FindInternalMemoCirculationsJoinIMOffset(limit int, offset int, order string, dir string, employeeID int) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationJoinIMParameter, err error) {
	var (
		orderDirection           string
		internalMemoCirculations []model.SelectInternalMemoCirculationJoinIMParameter
	)
	orderDirection = order + " " + dir
	res := db.connection.Table("internal_memo_circulations").Select("internal_memos.id, internal_memos.internal_memo_no, to_char(to_timestamp(internal_memos.internal_memo_date::numeric), 'DD-Mon-YYYY') as internal_memo_date, internal_memos.internal_memo_type_id, internal_memos.perihal_others, internal_memo_types.internal_memo_type_name, internal_memos.return_to_employee_id, returnToEmployeeID.firstname AS return_to_employee_name, internal_memos.document_no, internal_memos.company_id, companies.company_name, internal_memos.related_party, internal_memos.amount, internal_memos.amount_note, internal_memos.internal_memo_description, internal_memos.internal_memo_result, internal_memos.total_circulation, internal_memos.last_circulation_sequence_no, internal_memos.last_circulation_employee_id, lastCirculationEmployeeName.firstname AS last_circulation_employee_name, internal_memos.status, CASE WHEN internal_memos.status = 1 THEN 'Draft' WHEN internal_memos.status = 2 THEN 'Ask for Approval' WHEN internal_memos.status = 3 THEN 'Back to PIC' WHEN internal_memos.status = 4 THEN 'Approval Completed' WHEN internal_memos.status = 5 THEN 'Rejected' END AS status_name, internal_memos.remark, internal_memos.created_user_id, createdUID.username AS created_user, internal_memos.updated_user_id, updatedUID.username AS updated_user, internal_memos.deleted_user_id, deletedUID.username AS deleted_user, to_char(to_timestamp(internal_memos.created_at::numeric), 'DD-Mon-YYYY') as created_at, to_char(to_timestamp(internal_memos.updated_at::numeric), 'DD-Mon-YYYY') as updated_at, to_char(to_timestamp(internal_memos.deleted_at::numeric), 'DD-Mon-YYYY') as deleted_at, internal_memos.file_name, internal_memos.file_url").Joins("left join internal_memos on internal_memo_circulations.internal_memo_id = internal_memos.id").Joins("left join companies on internal_memos.company_id = companies.id").Joins("left join internal_memo_types on internal_memos.internal_memo_type_id = internal_memo_types.id").Joins("left join employees returnToEmployeeID on internal_memos.return_to_employee_id = returnToEmployeeID.id").Joins("left join employees lastCirculationEmployeeName on internal_memos.last_circulation_employee_id = lastCirculationEmployeeName.id").Joins("left join users createdUID on internal_memos.created_user_id = createdUID.id").Joins("left join users updatedUID on internal_memos.updated_user_id = updatedUID.id").Joins("left join users deletedUID on internal_memos.deleted_user_id = deletedUID.id").Where("internal_memo_circulations.employee_id = ? AND internal_memo_circulations.deleted_at = 0", employeeID).Order(orderDirection).Limit(limit).Offset(offset).Find(&internalMemoCirculations)
	return internalMemoCirculations, res.Error
}

func (db *InternalMemoCirculationConnection) SearchInternalMemoCirculationJoinIM(limit int, offset int, order string, dir string, search string, employeeID int) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationJoinIMParameter, err error) {
	var (
		orderDirection           string
		final                    string
		internalMemoCirculations []model.SelectInternalMemoCirculationJoinIMParameter
	)
	orderDirection = order + " " + dir
	final = "%" + strings.ToLower(search) + "%"
	res := db.connection.Table("internal_memo_circulations").Select("internal_memos.id, internal_memos.internal_memo_no, to_char(to_timestamp(internal_memos.internal_memo_date::numeric), 'DD-Mon-YYYY') as internal_memo_date, internal_memos.internal_memo_type_id, internal_memos.perihal_others, internal_memo_types.internal_memo_type_name, internal_memos.return_to_employee_id, returnToEmployeeID.firstname AS return_to_employee_name, internal_memos.document_no, internal_memos.company_id, companies.company_name, internal_memos.related_party, internal_memos.amount, internal_memos.amount_note, internal_memos.internal_memo_description, internal_memos.internal_memo_result, internal_memos.total_circulation, internal_memos.last_circulation_sequence_no, internal_memos.last_circulation_employee_id, lastCirculationEmployeeName.firstname AS last_circulation_employee_name, internal_memos.status, CASE WHEN internal_memos.status = 1 THEN 'Draft' WHEN internal_memos.status = 2 THEN 'Ask for Approval' WHEN internal_memos.status = 3 THEN 'Back to PIC' WHEN internal_memos.status = 4 THEN 'Approval Completed' WHEN internal_memos.status = 5 THEN 'Rejected' END AS status_name, internal_memos.remark, internal_memos.created_user_id, createdUID.username AS created_user, internal_memos.updated_user_id, updatedUID.username AS updated_user, internal_memos.deleted_user_id, deletedUID.username AS deleted_user, to_char(to_timestamp(internal_memos.created_at::numeric), 'DD-Mon-YYYY') as created_at, to_char(to_timestamp(internal_memos.updated_at::numeric), 'DD-Mon-YYYY') as updated_at, to_char(to_timestamp(internal_memos.deleted_at::numeric), 'DD-Mon-YYYY') as deleted_at, internal_memos.file_name, internal_memos.file_url").Joins("left join internal_memos on internal_memo_circulations.internal_memo_id = internal_memos.id").Joins("left join companies on internal_memos.company_id = companies.id").Joins("left join internal_memo_types on internal_memos.internal_memo_type_id = internal_memo_types.id").Joins("left join employees returnToEmployeeID on internal_memos.return_to_employee_id = returnToEmployeeID.id").Joins("left join employees lastCirculationEmployeeName on internal_memos.last_circulation_employee_id = lastCirculationEmployeeName.id").Joins("left join employees on internal_memo_circulations.employee_id = employees.id").Joins("left join divisions on employees.division_id = divisions.id").Joins("left join departments on employees.department_id = departments.id").Joins("left join users createdUID on internal_memo_circulations.created_user_id = createdUID.id").Joins("left join users updatedUID on internal_memo_circulations.updated_user_id = updatedUID.id").Joins("left join users deletedUID on internal_memo_circulations.deleted_user_id = deletedUID.id").Where("(lower(internal_memos.internal_memo_no) LIKE ? OR lower(internal_memos.perihal_others) LIKE ? OR lower(to_char(to_timestamp(internal_memos.internal_memo_date::numeric), 'DD-Mon-YYYY')) LIKE ? OR lower(internal_memo_types.internal_memo_type_name) LIKE ? OR lower(returnToEmployeeID.firstname) LIKE ? OR lower(internal_memos.document_no) LIKE ? OR lower(companies.company_name) LIKE ? OR lower(internal_memos.related_party) LIKE ? OR lower(internal_memos.amount::text) LIKE ? OR lower(internal_memos.amount_note) LIKE ? OR lower(internal_memos.internal_memo_description) LIKE ? OR lower(internal_memos.internal_memo_result) LIKE ? OR lower(to_char(to_timestamp(internal_memos.last_date::numeric), 'DD-Mon-YYYY')) LIKE ? OR lower(internal_memos.total_circulation::text) LIKE ? OR lower(internal_memos.last_circulation_sequence_no::text) LIKE ? OR lower(lastCirculationEmployeeName.firstname) LIKE ? OR (CASE WHEN internal_memos.status = 1 THEN 'draft' WHEN internal_memos.status = 2 THEN 'ask for approval' WHEN internal_memos.status = 3 THEN 'back to pic' WHEN internal_memos.status = 4 THEN 'approval completed' WHEN internal_memos.status = 5 THEN 'rejected' END LIKE ?) OR lower(internal_memos.remark) LIKE ? OR lower(createdUID.username) LIKE ? OR lower(to_char(to_timestamp(internal_memos.created_at::numeric), 'DD-Mon-YYYY')) LIKE ? OR lower(updatedUID.username) LIKE ? OR lower(to_char(to_timestamp(internal_memos.updated_at::numeric), 'DD-Mon-YYYY')) LIKE ?) AND internal_memo_circulations.employee_id = ? AND internal_memos.deleted_at = 0", final, final, final, final, final, final, final, final, final, final, final, final, final, final, final, final, final, final, final, final, final, final, employeeID).Order(orderDirection).Limit(limit).Offset(offset).Find(&internalMemoCirculations)

	return internalMemoCirculations, res.Error
}

func (db *InternalMemoCirculationConnection) CountSearchInternalMemoCirculationJoinIM(search string, employeeID int) (internalMemoCirculationOutput []model.SelectInternalMemoCirculationJoinIMParameter, err error) {
	var (
		final                    string
		internalMemoCirculations []model.SelectInternalMemoCirculationJoinIMParameter
	)
	final = "%" + strings.ToLower(search) + "%"
	res := db.connection.Table("internal_memo_circulations").Select("internal_memos.id, internal_memos.internal_memo_no, to_char(to_timestamp(internal_memos.internal_memo_date::numeric), 'DD-Mon-YYYY') as internal_memo_date, internal_memos.internal_memo_type_id, internal_memos.perihal_others, internal_memo_types.internal_memo_type_name, internal_memos.return_to_employee_id, returnToEmployeeID.firstname AS return_to_employee_name, internal_memos.document_no, internal_memos.company_id, companies.company_name, internal_memos.related_party, internal_memos.amount, internal_memos.amount_note, internal_memos.internal_memo_description, internal_memos.internal_memo_result, internal_memos.total_circulation, internal_memos.last_circulation_sequence_no, internal_memos.last_circulation_employee_id, lastCirculationEmployeeName.firstname AS last_circulation_employee_name, internal_memos.status, CASE WHEN internal_memos.status = 1 THEN 'Draft' WHEN internal_memos.status = 2 THEN 'Ask for Approval' WHEN internal_memos.status = 3 THEN 'Back to PIC' WHEN internal_memos.status = 4 THEN 'Approval Completed' WHEN internal_memos.status = 5 THEN 'Rejected' END AS status_name, internal_memos.remark, internal_memos.created_user_id, createdUID.username AS created_user, internal_memos.updated_user_id, updatedUID.username AS updated_user, internal_memos.deleted_user_id, deletedUID.username AS deleted_user, to_char(to_timestamp(internal_memos.created_at::numeric), 'DD-Mon-YYYY') as created_at, to_char(to_timestamp(internal_memos.updated_at::numeric), 'DD-Mon-YYYY') as updated_at, to_char(to_timestamp(internal_memos.deleted_at::numeric), 'DD-Mon-YYYY') as deleted_at, internal_memos.file_name, internal_memos.file_url").Joins("left join internal_memos on internal_memo_circulations.internal_memo_id = internal_memos.id").Joins("left join companies on internal_memos.company_id = companies.id").Joins("left join internal_memo_types on internal_memos.internal_memo_type_id = internal_memo_types.id").Joins("left join employees returnToEmployeeID on internal_memos.return_to_employee_id = returnToEmployeeID.id").Joins("left join employees lastCirculationEmployeeName on internal_memos.last_circulation_employee_id = lastCirculationEmployeeName.id").Joins("left join employees on internal_memo_circulations.employee_id = employees.id").Joins("left join divisions on employees.division_id = divisions.id").Joins("left join departments on employees.department_id = departments.id").Joins("left join users createdUID on internal_memo_circulations.created_user_id = createdUID.id").Joins("left join users updatedUID on internal_memo_circulations.updated_user_id = updatedUID.id").Joins("left join users deletedUID on internal_memo_circulations.deleted_user_id = deletedUID.id").Where("(lower(internal_memos.internal_memo_no) LIKE ? OR lower(internal_memos.perihal_others) LIKE ? OR lower(to_char(to_timestamp(internal_memos.internal_memo_date::numeric), 'DD-Mon-YYYY')) LIKE ? OR lower(internal_memo_types.internal_memo_type_name) LIKE ? OR lower(returnToEmployeeID.firstname) LIKE ? OR lower(internal_memos.document_no) LIKE ? OR lower(companies.company_name) LIKE ? OR lower(internal_memos.related_party) LIKE ? OR lower(internal_memos.amount::text) LIKE ? OR lower(internal_memos.amount_note) LIKE ? OR lower(internal_memos.internal_memo_description) LIKE ? OR lower(internal_memos.internal_memo_result) LIKE ? OR lower(to_char(to_timestamp(internal_memos.last_date::numeric), 'DD-Mon-YYYY')) LIKE ? OR lower(internal_memos.total_circulation::text) LIKE ? OR lower(internal_memos.last_circulation_sequence_no::text) LIKE ? OR lower(lastCirculationEmployeeName.firstname) LIKE ? OR (CASE WHEN internal_memos.status = 1 THEN 'draft' WHEN internal_memos.status = 2 THEN 'ask for approval' WHEN internal_memos.status = 3 THEN 'back to pic' WHEN internal_memos.status = 4 THEN 'approval completed' WHEN internal_memos.status = 5 THEN 'rejected' END LIKE ?) OR lower(internal_memos.remark) LIKE ? OR lower(createdUID.username) LIKE ? OR lower(to_char(to_timestamp(internal_memos.created_at::numeric), 'DD-Mon-YYYY')) LIKE ? OR lower(updatedUID.username) LIKE ? OR lower(to_char(to_timestamp(internal_memos.updated_at::numeric), 'DD-Mon-YYYY')) LIKE ?) AND internal_memo_circulations.employee_id = ? AND internal_memos.deleted_at = 0", final, final, final, final, final, final, final, final, final, final, final, final, final, final, final, final, final, final, final, final, final, final, employeeID).Find(&internalMemoCirculations)
	return internalMemoCirculations, res.Error
}
